# 线程池
顾名思义，就是存放线程的地方。如果没有线程池，我们在使用线程时需要去创建，使用完后还得销毁，整个过程是很耗费时间和资源的。有了线程池之后，就可以直接从线程池中获得线程。简单地理解，ExecutorService的实例就是线程池。

## Executor
是Java线程池的超级接口，提供一个execute(Runnable command)方法，我们一般用它的继承接口ExecutorService。

## ExecutorService
ExecutorService的实例就是线程池。它是线程池定义的一个接口，继承Executor。有两个实现类，分别为ThreadPoolExecutor, ScheduledThreadPoolExecutor。我们也可以很方便地使用Executors工厂类来帮我们创建

## Executors工厂类
是java.util.concurrent包下的一个工厂类，提供各种静态方法，可以用来创建不同类型的线程池。

### Executors可以创建以下四种不同类型的线程池
 - `newCachedThreadPool`：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
 - `newFixedThreadPool`：创建一个定长的线程池，可控制线程最大并发数，超出的线程会在队列中等待。
 - `newSingleThreadExecutor`：相当于创建一个线程数量为1的`newFixedThreadPool`，每次只能执行一个任务，多的任务将进行排队，
 - `newScheduledThreadPool`：创建一个线程池，可以在延迟后执行命令，或者定期地执行

### shutdown()
我们使用完成ExecutorService之后应该关闭它，否则它里面的线程会一直处于运行状态。  

举个例子，如果的应用程序是通过main()方法启动的，在这个main()退出之后，如果应用程序中的ExecutorService没有关闭，这个应用将一直运行。之所以会出现这种情况，是因为ExecutorService中运行的线程会阻止JVM关闭。

如果要关闭ExecutorService中执行的线程，我们可以调用ExecutorService.shutdown()方法。在调用`shutdown()`方法之后，ExecutorService不会立即关闭，但是它不再接收新的任务，直到当前所有线程执行完成才会关闭，所有在shutdown()执行之前提交的任务都会被执行。

如果我们想立即关闭ExecutorService，我们可以调用`ExecutorService.shutdownNow()`方法。这个动作将跳过所有正在执行的任务和被提交还没有执行的任务。但是它并不对正在执行的任务做任何保证，有可能它们都会停止，也有可能执行完成。
